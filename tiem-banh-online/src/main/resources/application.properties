# src/main/resources/application.properties

# ==========================================
# APPLICATION CONFIGURATION
# ==========================================
# Application Name
spring.application.name=tiem-banh-online

# Server Port Configuration
server.port=8080

# ==========================================
# DATABASE CONFIGURATION (PostgreSQL)
# ==========================================
# Replace with your actual database connection details.
# For production, consider using environment variables or external configuration files.

spring.datasource.url=jdbc:postgresql://localhost:5432/tiem_banh
spring.datasource.username=postgres
# IMPORTANT: Externalize sensitive credentials like passwords in production!
spring.datasource.password=machdaodonglituonglc
spring.datasource.driver-class-name=org.postgresql.Driver

# Connection Pool Settings (HikariCP - Default) - Optional Fine-tuning
# spring.datasource.hikari.connection-timeout=30000 # milliseconds
# spring.datasource.hikari.idle-timeout=600000
# spring.datasource.hikari.max-lifetime=1800000
# spring.datasource.hikari.maximum-pool-size=10
# spring.datasource.hikari.minimum-idle=5

# ==========================================
# JPA / HIBERNATE CONFIGURATION
# ==========================================
# Use Spring Boot's recommended strategy for mapping camelCase fields to snake_case columns
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy
# Alternatively, use exact matching if your DB columns are camelCase or you map explicitly:
# spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# DDL Generation Strategy:
# validate: Check schema against entities, fail on mismatch (Recommended for production/stable dev).
# update: Automatically update schema (Use with caution, potential data loss during development).
# create-drop: Create schema on startup, drop on shutdown (Good for testing).
# create: Create schema on startup, does not drop (Can lead to issues on restart if data exists).
# none: Do nothing (Requires manual schema management or tools like Flyway/Liquibase).
spring.jpa.hibernate.ddl-auto=update

# Show SQL statements in logs (useful for development/debugging)
spring.jpa.show-sql=true

# Format SQL statements in logs for better readability (useful for development/debugging)
spring.jpa.properties.hibernate.format_sql=true

# Specify the database dialect for Hibernate (essential for correct SQL generation)
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Optional: Add comments to generated SQL (useful for debugging)
# spring.jpa.properties.hibernate.use_sql_comments=true

# Optional: Enable statistics for performance monitoring (can impact performance slightly)
# spring.jpa.properties.hibernate.generate_statistics=false

# ==========================================
# THYMELEAF CONFIGURATION
# ==========================================
# Disable Thymeleaf caching during development for immediate template changes.
# Set to 'true' in production for better performance.
spring.thymeleaf.cache=false

# Ensure UTF-8 encoding is used for templates and output
spring.thymeleaf.encoding=UTF-8
spring.thymeleaf.servlet.content-type=text/html; charset=UTF-8

# Default template prefix and suffix (usually don't need to change)
# spring.thymeleaf.prefix=classpath:/templates/
# spring.thymeleaf.suffix=.html
# spring.thymeleaf.mode=HTML

# ==========================================
# LOGGING CONFIGURATION
# ==========================================
# Set logging levels for specific packages
# Use DEBUG for detailed application logs during development
logging.level.com.tiembanhngot.tiem_banh_online=DEBUG
# Use INFO for general Spring framework logs
logging.level.org.springframework.web=INFO
# Set to DEBUG for more security-related details during development if needed
logging.level.org.springframework.security=INFO
# Show executed SQL statements (redundant if spring.jpa.show-sql=true, but good practice)
logging.level.org.hibernate.SQL=DEBUG
# Log JDBC bind parameter values (very verbose, use for deep parameter debugging)
logging.level.org.hibernate.type.descriptor.sql=TRACE
# Set root logger level (e.g., INFO for general output)
logging.level.root=INFO

# Log file configuration (optional)
# logging.file.name=logs/tiem-banh-online.log
# logging.file.path=./logs # Relative path
# logging.file.max-size=10MB
# logging.file.max-history=10

# Console logging pattern (optional customization)
# logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger{36} - %msg%n

# ==========================================
# SPRING SECURITY CONFIGURATION (Optional Overrides)
# ==========================================
# No specific overrides needed here as configuration is done in SecurityConfig.java

# ==========================================
# WEB CONFIGURATION
# ==========================================
# Configure static resource locations (defaults are usually sufficient)
spring.web.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/

# Configure cache control for static resources (example: cache for 1 day in production)
# Make sure spring.thymeleaf.cache=true is set in production profile for this to be effective
# spring.web.resources.cache.cachecontrol.max-age=P1D # Period format (1 day)
# spring.web.resources.cache.cachecontrol.cache-public=true

# ==========================================
# FILE UPLOAD CONFIGURATION 
# ==========================================
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
spring.servlet.multipart.location=/path/to/temp/upload/dir # Optional explicit temp location
# File Upload Configuration
app.upload.dir=./uploads/
# Google Gemini API Configuration
google.api.key=AIzaSyAylQCJhvqInn00la6oELvMsw360tYguYE
google.project.id=chatbox-459917
google.location=us-central1
google.credentials.path=classpath:service-account-key.json
